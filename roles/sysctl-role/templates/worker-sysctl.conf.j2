#DEVICE

# TIOCSTI can be used by a program to simulate user typing
dev.tty.legacy_tiocsti = 0

#HPET is a hardware timer.To prevent abuse (e.g., malicious or buggy apps requesting 100,000 interrupts per second and killing performance), the kernel enforces this maximum frequency.
#How many interrupts can application make in one second
dev.hpet.max-user-freq = 64

#****************************************************************************************************************************
#FILESYSTEM

#Only the owner of a FIFO or root can open it for writing before any process reads from it.
fs.protected_fifos = 1
#Restricts creating hardlinks to files the user does not own (unless they have read/write access).
fs.protected_hardlinks = 1
#Controls restrictions for opening regular files in world-writable sticky directories (like /tmp).
fs.protected_regular = 2
#Prevents following symlinks in world-writable sticky directories (e.g., /tmp) if the symlink points to a file the follower shouldn’t access
fs.protected_symlinks = 1

#Controls whether the kernel allows core dumps from processes that have changed their privileges (Contains : Passwords, keys, tokens,Application logic.)
#0 -> no dumps - most secure, 2 -> dumps are allowed but in dir where root only have access - useful for debugging
fs.suid_dumpable = 0
#****************************************************************************************************************************
#KERNEL

#Disable CTRL+ALT+ commands.Disable SysRq (limits kernel-level commands)
kernel.sysrq = 0

#Core dump files include PID
kernel.core_uses_pid = 1

#Restricts non-root users to access kernel messages through dmesg
kernel.dmesg_restrict = 1


#Hide kernel pointers (addresses in kernel memory) in /proc from un-privileged users.Set 2 to hide it even from root.
kernel.kptr_restrict = 1

#It uses Non-Maskable Interrupts (NMIs) to periodically check whether CPUs are responding.
kernel.nmi_watchdog = 0

#4 → Completely disables perf_event_open for unprivileged users.
kernel.perf_event_paranoid = 4

#ASLR randomizes the memory addresses used by processes so that exploits relying on fixed addresses (like buffer overflows) are harder.
kernel.randomize_va_space = 2

##When the creating process dies, all its shared memory segments are automatically destroyed (like POSIX shared memory behavior).
kernel.shm_rmid_forced = 1

#Controls how strictly the kernel enforces sysctl write permissions.Prevents accidental or malicious changes to critical kernel settings.Controls how strictly the kernel validates writes to /proc/sys entries.Writes must exactly match the expected format.
kernel.sysctl_writes_strict = 1

#Unprivileged users cannot create BPF programs (restricted).BPF programs are used for network filtering, tracing, and performance monitoring.
kernel.unprivileged_bpf_disabled = 1

#Allows creating User namespaces for unprivileged users.Security risk,keep disabled unless running rootless containers or apps that are using namespaces.
kernel.unprivileged_userns_clone = 0

#1 → restricted ptrace. A process can only trace Its child processes and Processes with CAP_SYS_PTRACE capability.
kernel.yama.ptrace_scope = 1

#It uses Non-Maskable Interrupts (NMIs) to periodically check whether CPUs are responding.
kernel.nmi_watchdog = 1




#Whether a system should reboot on panic.Keep on 0 if you want to investigate before reboot.Chnage to 1 on where uptime is critical.
kernel.panic = 10
kernel.panic_on_io_nmi = 0
kernel.panic_on_oops = 1
kernel.panic_on_rcu_stall = 0
kernel.panic_on_unrecovered_nmi = 0
kernel.panic_on_warn = 0


#******************************************************************************************************************************
#VIRTUAL MEMORY(VM)

#Soft-offlining means:Mark the faulty page as offline.Avoid using it in the future.No need to reboot the system
#If disabled (0):Faulty pages may cause kernel oops/panic when accessed.
vm.enable_soft_offline = 1

#A file descriptor–based API (/dev/userfaultfd) that lets a userspace process handle page faults on behalf of another process.
vm.unprivileged_userfaultfd = 0

#How often in seconds are memory statistics refreshed.(/proc/vmstat)
vm.stat_interval = 1

#0 -> The kernel runs the OOM killer heuristic.The process with the highest score is killed, not necessarily the one that requested the memory.This helps protect critical processes
vm.oom_kill_allocating_task = 0

#Linux hardening knob that controls whether memory file descriptors (memfd) can be used to create executable anonymous memory
#1 -> Systems running : Web Browsers,OpenJDK / JVM,Node.js / V8,.NET CoreeBPF JIT in the kernel
#2 -> Systems running : classic web/db hosts running nginx/httpd/PostgreSQL, no JVM/Node/Chromium/etc.
vm.memfd_noexec = 1

# Prevent users from mapping memory they shouldn't.Defines the lowest virtual address (in bytes) that a process (especially an unprivileged one) is allowed to map using mmap()
vm.mmap_min_addr = 65536

#How often to use swap.Lower number=Less used.0-100
vm.swappiness = 0


#******************************************************************************************************************************
#NET

# Allow iptables to see bridged traffic
net.bridge.bridge-nf-call-iptables = 1
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-arptables = 1


#Compile BPF programs into native instrustions.(Faster)
net.core.bpf_jit_enable = 1

#2 – harden JIT for all users (recommended by many security baselines, e.g., RHEL/Alma STIGs)
net.core.bpf_jit_harden = 2

##How many packets from same stream are stacked together before passing them.
#8 -> Balanced — good throughput with minimal added latency.Works well for most general-purpose servers.
net.core.gro_normal_batch = 8


#Linux introduced nexthop objects to make ECMP and multipath routing more powerful.Ensures older tooling (ip route add ... nexthop) and daemons still work.
net.ipv4.nexthop_compat_mode = 1

#IPV4 Forwarding
net.ipv4.ip_forward = 1

#ARP & Neighbor Filtering (protects against spoofing in L2):These stop the node from responding to ARP on wrong interfaces.
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.all.arp_announce = 2

#Default 0. if your server has IP 192.168.1.10, it shouldn’t be receiving packets that claim to come from 192.168.1.10 — that looks like a spoofed packet or a loop.
net.ipv4.conf.all.accept_local = 0

#Disable!Allows to specify full route of packets.This controls whether new network interfaces will, by default, accept IP source-routed packets.
net.ipv4.conf.all.accept_source_route = 0

#Disable (0)  on most modern servers.Controls whether new network interfaces will, by default, accept ICMP Redirect messages.#best practice in secure environments is to disable sending redirects, unless your server is acting as a trusted router.
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.conf.all.secure_redirects = 0
net.ipv4.conf.all.send_redirects = 0

#This controls whether the kernel forwards broadcast packets received on an interface to other interfaces.
net.ipv4.conf.all.bc_forwarding = 0
#This controls whether the host forwards IPv4 multicast traffic between interfaces.
net.ipv4.conf.all.mc_forwarding = 0

#Reverse Path Filtering checks whether the source address of a packet is reachable via the interface it arrived on.
#Value 1.Strict mode.
#Value 2.Recommended in cloud enviroments.The kernel only checks if the source IP is present in the routing table (reachable at all).
net.ipv4.conf.all.rp_filter = 2

#1 -> Protects against SYN floods and half-open connection abuse.
net.ipv4.tcp_backlog_ack_defer = 1

#Allow windows scaling.The TCP receive window (RWIN) tells the sender how much data you can send me before I must ACK
net.ipv4.tcp_window_scaling = 1

#Controls whether the TCP stack automatically “corks” (delays) small writes from applications, so they can be coalesced into fewer, larger packets.
#1 -> Reduces packet overhead and improves throughput.
net.ipv4.tcp_autocorking = 1

#Sender sees congestion early and slows down before loss occurs.congestion = too much traffic injected into the network vs. what it can drain.
net.ipv4.tcp_ecn = 1

#Client includes the cookie + data in SYN.Server validates cookie and accepts data right away.Problem middlebox break it.
#Keep disabled,replaced with TLS.If client has a session ticket from a prior TLS handshake, it can send data immediately with the ClientHello.
net.ipv4.tcp_fastopen = 0

#This controls whether a TCP socket in the request queue (half-open connections that have received SYN and sent SYN-ACK, waiting for the final ACK) can be migrated from one listening socket to another.
net.ipv4.tcp_migrate_req = 0

#Enable/Disable SACK
net.ipv4.tcp_sack = 1

#Enable/Disable Timestamp
net.ipv4.tcp_timestamps = 1

#SYN flood / backlog protection.SYN cookies let the server withstand floods by avoiding allocation for half-opens.
#When backlog is full, the server does not allocate memory for the half-open connection.it encodes essential state (MSS, timestamp, etc.) into the server’s SYN-ACK sequence number.If the client responds with the final ACK, the server validates the cookie → only then allocates memory and establishes the connection.
net.ipv4.tcp_syncookies = 1

#Lets sockets in TIME_WAIT be reused for new connections faster.
net.ipv4.tcp_tw_reuse = 0

#Disable broadcast ping (old DoS vector)
net.ipv4.icmp_echo_ignore_broadcasts = 1

#If you are using port for something specify it here so it avoids conflicts
net.ipv4.ip_local_reserved_ports = {{ worker_reserved_ports }} 

net.ipv4.conf.all.log_martians = 1
net.ipv4.conf.default.log_martians = 1





#Upper bound for an app’s accept queue (fully established connections waiting for accept()).
net.core.somaxconn = 16384
#Size of the SYN (half-open) queue per listening socket—connections that have received SYN and you’ve sent SYN-ACK, waiting for the final ACK.
net.ipv4.tcp_max_syn_backlog = 16384
#Per-CPU queue for ingress packets that the kernel hasn’t yet processed to the stack.
net.core.netdev_max_backlog = 65536

#Max R/W memory per socket(connection) 4MiB
net.core.rmem_max = 2097152
net.core.wmem_max = 2097152

#It’s the system-wide pool of memory that all TCP sockets on the host share.
#net.ipv4.tcp_mem = 91968 122625 183936

#Per Socket up to 2MiB
net.ipv4.tcp_rmem = 4096 131072 2097152
net.ipv4.tcp_wmem = 4096 131072 2097152

#If packets are arriving faster than the app consumes them:Kernel grows the receive buffer gradually.If app drains fast or traffic slows:Kernel keeps buffer moderate; doesn’t waste memory.
net.ipv4.tcp_moderate_rcvbuf = 1

#reset cwnd after idle → safer for the Internet.
net.ipv4.tcp_slow_start_after_idle = 1

#Governs how many times TCP will retransmit data on an established connection before giving up.
net.ipv4.tcp_retries2 = 15

#how many times the server resends SYN-ACK before abandoning the half-open handshake and freeing the slot
tcp_synack_retries = 5

#if system is tight on memory and there are many TCP sockets, Linux will send probes to idle connections every 10 minutes to check if they’re still alive.
net.ipv4.tcp_probe_interval = 300

#How long before kernel closes idle connection.They define when the kernel sends probes on otherwise idle TCP connections, and when it gives up if the peer doesn’t respond.
net.ipv4.tcp_keepalive_intvl = 60 
net.ipv4.tcp_keepalive_probes = 5
net.ipv4.tcp_keepalive_time = 300






net.ipv6.conf.all.forwarding = 0
net.ipv6.conf.default.forwarding = 0

net.ipv6.conf.all.disable_ipv6 = 0
net.ipv6.conf.default.disable_ipv6 = 0
#0 = ignore ICMPv6 redirects (recommended).
net.ipv6.conf.all.accept_redirects = 0
#0 = disable (recommended). Prevents source-routed packet abuse.
net.ipv6.conf.all.accept_source_route = 0
#2 = always prefer temporary addresses (default on most distros).
net.ipv6.conf.all.use_tempaddr = 2

net.ipv6.conf.all.accept_ra = 0







