#DEVICE

# TIOCSTI can be used by a program to simulate user typing
dev.tty.legacy_tiocsti = 0

#HPET is a hardware timer.To prevent abuse (e.g., malicious or buggy apps requesting 100,000 interrupts per second and killing performance), the kernel enforces this maximum frequency.
#How many interrupts can application make in one second
dev.hpet.max-user-freq = 64

#****************************************************************************************************************************
#FILESYSTEM

#Only the owner of a FIFO or root can open it for writing before any process reads from it.
fs.protected_fifos = 1
#Restricts creating hardlinks to files the user does not own (unless they have read/write access).
fs.protected_hardlinks = 1
#Controls restrictions for opening regular files in world-writable sticky directories (like /tmp).
fs.protected_regular = 2
#Prevents following symlinks in world-writable sticky directories (e.g., /tmp) if the symlink points to a file the follower shouldn’t access
fs.protected_symlinks = 1

#Controls whether the kernel allows core dumps from processes that have changed their privileges (Contains : Passwords, keys, tokens,Application logic.)
#0 -> no dumps - most secure, 2 -> dumps are allowed but in dir where root only have access - useful for debugging
fs.suid_dumpable = 0
#****************************************************************************************************************************
#KERNEL

#Disable CTRL+ALT+ commands.Disable SysRq (limits kernel-level commands)
kernel.sysrq = 0

#Core dump files include PID
kernel.core_uses_pid = 1

#Restricts non-root users to access kernel messages through dmesg
kernel.dmesg_restrict = 1

#io_uring is still young, and it has had several privilege escalation / memory corruption CVEs (e.g., CVE-2021-41073, CVE-2022-1786).
#Keep 0 → modern servers, databases, or applications requiring high-performance asynchronous I/O.
kernel.io_uring_disabled = 2

#Linux that lets you load a new kernel into memory and jump to it without going through the full BIOS/UEFI + hardware initialization cycle.
kernel.kexec_load_disabled = 1


#Hide kernel pointers (addresses in kernel memory) in /proc from un-privileged users.Set 2 to hide it even from root.
kernel.kptr_restrict = 1

#It uses Non-Maskable Interrupts (NMIs) to periodically check whether CPUs are responding.
kernel.nmi_watchdog = 1

#4 → Completely disables perf_event_open for unprivileged users.
kernel.perf_event_paranoid = 4

#ASLR randomizes the memory addresses used by processes so that exploits relying on fixed addresses (like buffer overflows) are harder.
kernel.randomize_va_space = 2

##When the creating process dies, all its shared memory segments are automatically destroyed (like POSIX shared memory behavior).
kernel.shm_rmid_forced = 1

#1 → Enabled (default on most modern kernels). The kernel uses CPU features to detect or mitigate split locks, reducing performance impact or potential security issues.
kernel.split_lock_mitigate = 1

#If a CPU is stuck in kernel code too long (e.g. infinite loop, deadlock, hardware hang):The watchdog logs a “soft lockup” warning.If configured (kernel.softlockup_panic=1), the system can panic/reboot.
kernel.watchdog = 1


#Controls how strictly the kernel enforces sysctl write permissions.Prevents accidental or malicious changes to critical kernel settings.Controls how strictly the kernel validates writes to /proc/sys entries.Writes must exactly match the expected format.
kernel.sysctl_writes_strict = 1

#Unprivileged users cannot create BPF programs (restricted).BPF programs are used for network filtering, tracing, and performance monitoring.
kernel.unprivileged_bpf_disabled = 1

#Allows creating User namespaces for unprivileged users.Security risk,keep disabled unless running rootless containers or apps that are using namespaces.
kernel.unprivileged_userns_clone = 0

#1 → restricted ptrace. A process can only trace Its child processes and Processes with CAP_SYS_PTRACE capability.
kernel.yama.ptrace_scope = 1
#******************************************************************************************************************************
#VIRTUAL MEMORY(VM)

#Soft-offlining means:Mark the faulty page as offline.Avoid using it in the future.No need to reboot the system
#If disabled (0):Faulty pages may cause kernel oops/panic when accessed.
vm.enable_soft_offline = 1

#A file descriptor–based API (/dev/userfaultfd) that lets a userspace process handle page faults on behalf of another process.
vm.unprivileged_userfaultfd = 0

#How often in seconds are memory statistics refreshed.(/proc/vmstat)
vm.stat_interval = 1

#0 -> The kernel runs the OOM killer heuristic.The process with the highest score is killed, not necessarily the one that requested the memory.This helps protect critical processes
vm.oom_kill_allocating_task = 0

#Linux hardening knob that controls whether memory file descriptors (memfd) can be used to create executable anonymous memory
#1 -> Systems running : Web Browsers,OpenJDK / JVM,Node.js / V8,.NET CoreeBPF JIT in the kernel
#2 -> Systems running : classic web/db hosts running nginx/httpd/PostgreSQL, no JVM/Node/Chromium/etc.
vm.memfd_noexec = 1

# Prevent users from mapping memory they shouldn't.Defines the lowest virtual address (in bytes) that a process (especially an unprivileged one) is allowed to map using mmap()
vm.mmap_min_addr = 65536


#******************************************************************************************************************************
#NET

#Compile BPF programs into native instrustions.(Faster)
net.core.bpf_jit_enable = 1

#2 – harden JIT for all users (recommended by many security baselines, e.g., RHEL/Alma STIGs)
net.core.bpf_jit_harden = 2


##How many packets from same stream are stacked together before passing them.
#8 -> Balanced — good throughput with minimal added latency.Works well for most general-purpose servers.
net.core.gro_normal_batch = 8

#Linux introduced nexthop objects to make ECMP and multipath routing more powerful.Ensures older tooling (ip route add ... nexthop) and daemons still work.
net.ipv4.nexthop_compat_mode = 1

#IPV4 Forwarding
net.ipv4.ip_forward = 0

#Default 0. if your server has IP 192.168.1.10, it shouldn’t be receiving packets that claim to come from 192.168.1.10 — that looks like a spoofed packet or a loop.
net.ipv4.conf.all.accept_local = 0

#Disable!Allows to specify full route of packets.This controls whether new network interfaces will, by default, accept IP source-routed packets.
net.ipv4.conf.all.accept_source_route = 0

#Disable (0)  on most modern servers.Controls whether new network interfaces will, by default, accept ICMP Redirect messages.#best practice in secure environments is to disable sending redirects, unless your server is acting as a trusted router.
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.conf.all.secure_redirects = 0
net.ipv4.conf.all.send_redirects = 0

#This controls whether the kernel forwards broadcast packets received on an interface to other interfaces.
net.ipv4.conf.all.bc_forwarding = 0
#This controls whether the host forwards IPv4 multicast traffic between interfaces.
net.ipv4.conf.all.mc_forwarding = 0

#Reverse Path Filtering checks whether the source address of a packet is reachable via the interface it arrived on.
#Value 1.Strict mode.
#Value 2.Recommended in cloud enviroments.The kernel only checks if the source IP is present in the routing table (reachable at all).
net.ipv4.conf.all.rp_filter = 2

#Allow windows scaling.The TCP receive window (RWIN) tells the sender how much data you can send me before I must ACK
net.ipv4.tcp_window_scaling = 1

#Controls whether the TCP stack automatically “corks” (delays) small writes from applications, so they can be coalesced into fewer, larger packets.
#1 -> Reduces packet overhead and improves throughput.
net.ipv4.tcp_autocorking = 1

#Sender sees congestion early and slows down before loss occurs.congestion = too much traffic injected into the network vs. what it can drain.
net.ipv4.tcp_ecn = 1

#Enable/Disable SACK
net.ipv4.tcp_sack = 1

#Enable/Disable Timestamp
net.ipv4.tcp_timestamps = 1

#Normally, TCP relies on ICMP “Fragmentation Needed” messages to learn the correct MTU. But many networks/firewalls block ICMP, which can leave connections “stuck.”
#Enabled on “blackhole detection.” If packets fail repeatedly, TCP starts probing with smaller MSS until it works.
net.ipv4.tcp_mtu_probing = 1

#SYN flood / backlog protection.SYN cookies let the server withstand floods by avoiding allocation for half-opens.
#When backlog is full, the server does not allocate memory for the half-open connection.it encodes essential state (MSS, timestamp, etc.) into the server’s SYN-ACK sequence number.If the client responds with the final ACK, the server validates the cookie → only then allocates memory and establishes the connection.
net.ipv4.tcp_syncookies = 1

#0 -> Disable TIME_WAIT reuse of connection.1/2 Useful for proxy/load balancing servers
net.ipv4.tcp_tw_reuse = 0

#Without it, a stray RST/FIN packet (with old sequence numbers) could kill a valid connection in TIME_WAIT.
net.ipv4.tcp_rfc1337 = 1

#This controls whether a TCP socket in the request queue (half-open connections that have received SYN and sent SYN-ACK, waiting for the final ACK) can be migrated from one listening socket to another.
net.ipv4.tcp_migrate_req = 0


#If packets are arriving faster than the app consumes them:Kernel grows the receive buffer gradually.If app drains fast or traffic slows:Kernel keeps buffer moderate; doesn’t waste memory.
net.ipv4.tcp_moderate_rcvbuf = 1

#reset cwnd after idle → safer for the Internet.
net.ipv4.tcp_slow_start_after_idle = 1

#Governs how many times TCP will retransmit data on an established connection before giving up.
net.ipv4.tcp_retries2 = 15






net.ipv6.conf.{all,default}.disable_ipv6 = 1
